# 03_04 Configure NGINX as a Load Balancer

Load balancing across multiple application instances is a commonly used technique for optimizing resource utilization, maximizing throughput, reducing latency, and ensuring fault-tolerant configurations.


- [Instructor] NGINX's proxy and load balancer functions are very similar. In fact, they're pretty much the same. The only difference is the number of servers in the upstream and the method used to connect to each of the servers in turn. Let's take a look at the different load balancing methods used by NGINX. NGINX uses three methods to connect to upstream servers, round-robin, least connections, and IP hashing. These methods are indicated with directives applied within an upstream block. NGINX also uses a weight directive to modify these three methods. The default method is round-robin, and there's no directive to use this method. Requests are sent to each upstream server one at a time with no preference given to the server. This is an easy reasonable method for evenly distributing a load over several servers. With the least connections method NGINX considers the number of connections and upstream server is already processing. The server with the fewest connections will be preferred for every new request that comes in. The IP hash method is used for session persistence. This method considers the IP address of the client making the request. And then chooses an upstream server to handle the request. If the client's IP address stays the same, the same upstream server will handle any future requests made by the client. The weight directive is used to influence the other methods. Since each server is considered evenly in the round-robin method and by connections in the least connections method, a weight can be applied to a server to give it higher preference. Take for example, a group of upstream servers where one server has twice the CPU or memory compared to the other servers, we could give that server a higher weight. So NGINX can route more traffic to that server. Now let's take a look at examples of these load balancing methods. I'm connected to my sandbox server as the root user. I've clone the exercise files to this system, and I'm located in the directory for this lesson. There are two files we need to consider, an NGINX configuration and a Python script. Let's take a look at the script first. We've used this script in a previous lesson to start a single app server. This time the script has been updated to start three app servers, each listening on a different port. The NGINX will use these servers in multiple upstream blocks. Let's take a look at that configuration. I'm editing the binaryville NGINX's configuration now and near the top of the file, there are four new upstream blocks. One for each method NGINX uses for load balancing, round-robin, least connections, IP hash, and weighted. Each one is named after the load balancing method used in that block. But that's only for reference in this example. In reality, you can give upstreams any name you'd like. You'll also notice that each upstream block contains the same servers. Fortunately NGINX allows servers to be used in multiple upstreams. This is useful in cases where we have upstream servers that we want to use across V hosts without having to define them over and over again. Now let's see the locations that connect to these upstreams in the main server. Near the bottom of the configuration are four locations. Each one named to match the upstream configurations they are associated with. Again, this naming is just for demonstration purposes. Each location uses the proxy pass directive, just like we used to demonstrate an upstream that connected to only one server. And just like in that case, each server name used in the proxy pass directives is immediately followed by a trailing slash. This is key to making sure our requests get mapped to the right path on the app servers. Okay, let's see this configuration in action. First, I need to put this configuration in place and reload the NGINX service. So I'll copy this configuration into the Etsy NGINX conf.d directory. And now I'll test the configuration with nginx-t. And now I'll reload NGINX with system CTL. Okay, our configuration is in place. Let me clear the screen and start the app servers. I'll do that with Python 3 followed by the name of the script. Now let's see how these locations work in the browser. In the browser, let's start with the round-robin location. I'll add that to the end of the URL. When I load this location, each server in our load balancer should respond with the port it's listening on one after the other. The first response we get is 7,001, which is good. Now, if we refresh the page a few times we should see the port for each of the three app servers. There's 7,002 and there's 7,003. So indeed each app server is responding in turn. Now let's test the other load balancing method, starting with lease connections. I'll update the URL with least con. The least connections method is kind of hard to test in our demo environment because we can't create enough connections to see which upstream server is getting the most connections. So if I refresh the page a few times, there's 7,002 and there's 7,003 and there's 7,001 again. So it looks more like the round-robin method is being used. This is reasonable since round-robin is the default load balancing method. Okay, let's try the IP hash method. I'll update the URL to use the location IP hash. Loading this location I get 7,002. Now let me reload the page a few times, 7,002, 7,002, and 7,002. Now this test makes more sense. I'm using the same IP address to connect to our demo server. So NGINX will keep routing my request to the same server. Now let's look at the weighted upstreams. So I'll update the URL to use the location weighted. And this case, we have three servers in the upstream with the 7,001 server having a weight of two. We're also using the default round-robin method. So we should see twice as many connections to 7,001 compared to 7,002, and 7,003. Let's give it a shot. On the first load, we're already seeing 7,001. I'll refresh the page again. There's 7,002, 7,003, 7,001, and there's 7,001 again on my next reload followed by